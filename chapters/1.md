<!-- Copy and paste the converted output. -->


<p style="color: red; font-weight: bold">>>>>>  gd2md-html alert:  ERRORs: 0; WARNINGs: 0; ALERTS: 5.</p>
<ul style="color: red; font-weight: bold"><li>See top comment block for details on ERRORs and WARNINGs. <li>In the converted Markdown or HTML, search for inline alerts that start with >>>>>  gd2md-html alert:  for specific instances that need correction.</ul>

<p style="color: red; font-weight: bold">Links to alert messages:</p><a href="#gdcalert1">alert1</a>
<a href="#gdcalert2">alert2</a>
<a href="#gdcalert3">alert3</a>
<a href="#gdcalert4">alert4</a>
<a href="#gdcalert5">alert5</a>

<p style="color: red; font-weight: bold">>>>>> PLEASE check and correct alert issues and delete this message and the inline alerts.<hr></p>


<p dir="rtl">
 فصل اول</p>


<p dir="rtl">
 </p>


<p dir="rtl">
<strong> درک عمیق کارکرد جاواسکریپت</strong></p>




*   اهداف فصل :‌ 
    *   هدف یک
    *   هدف دو 
    *   هدف سه
    *   هدف چهار
    *   هدف پنج
    *   هدف شش

<p dir="rtl">
</p>


<p dir="rtl">
در این فصل قصد داریم به نحوه اجرای کدهای js توسط سیستم های مختلف و در مفهوم دقیق تر ، توسط موتورهای این زبان بپردازیم. یادگیری این مباحث سبب می‌شود تا بتوانیم با دیدی باز ، مسائل اولیه مربوط به جاواسکریپت را تحلیل و راهکارهای هوشمندانه تری برای حل مسائل پیش رو ارائه دهیم. در حقیقت با کمک مطالب این فصل متوجه می‌شوید هر کدام از کد هایی که در جاواسکریپت نوشتید ، دقیقا چگونه توسط موتور این زبان تشخیص داده شده و اجرایی می‌شود. بعد از اینکه می دانید چگونه موتور مورد استفاده زیرین با کد شما برخورد خواهد کرد، حس تسلط بهتری خواهید داشت. روش های متعددی که موتورها برای دانلود اسکریپت ها استفاده می‌کنند و چگونگی درک کدهای js توسط ماشین را متوجه خواهید شد.</p>


<p dir="rtl">
<strong>موتور جاواسکریپت</strong></p>


<p dir="rtl">
موتور جاواسکریپت یک برنامه کامپیوتری است که کدهای جاواسکریپت را اجرا می‌کند. اولین موتور جاواسکریپت صرفا وظیفه ترجمه کدهای js را برعهده داشت ، ولی همه موتورهای مدرن امروزی از کامپایل در لحظه ( JIT Compilation) استفاده می‌کنند.[^1]

<p dir="rtl">
اساس جاواسکریپت توسط مشخصات و قواعدی که توسط کمیته TC39 تعیین می‌گردد ، معنی پیدا می‌کند. موتورهای جاواسکریپت برای پیروی از این خصوصیات در هنگام اجرای ویژگی‌های مختلف در جاواسکریپت نیاز دارند. موتورهای جاواسکریپت اکثرا توسط توسعه دهندگان مرورگرهای وب توسعه داده می‌شوند و تقریبا اکثر مرورگرهای فعلی موتورهای اختصاصی خود را دارند و البته هدف تمام این موتورها رسیدن به ایده‌ آل‌ترین حالت اجرایی از قواعد تعیین شده توسط TC39 می‌باشد. بنابراین، غالب تکنیک‌های مربوط به عملکرد موتورهای جاواسکریپتی تقریبا در همه مرورگرها قابل استفاده هستند. </p>


<p dir="rtl">
اولین موتور جاواسکریپت توسط سازنده آن ، Brendan Eich در سال 1995 ساخته شد و بعدها همین موتور توسط کمپانی فایرفاکس توسعه داده شده و در مرورگرهای فعلی نیز استفاده می‌شود. به لیستی از مرورگرهای معروف به همراه موتور مورد استفاده آن‌ها در زیر توجه کنید :</p>



<table>
  <tr>
   <td><p dir="rtl">
<strong>مرورگر</strong></p>

   </td>
   <td><p dir="rtl">
<strong>موتور جاواسکریپت</strong></p>

   </td>
  </tr>
  <tr>
   <td><p dir="rtl">
Microsoft Edge</p>

   </td>
   <td><p style="text-align: right">
Chakra</p>

   </td>
  </tr>
  <tr>
   <td><p style="text-align: right">
Firefox</p>

   </td>
   <td><p style="text-align: right">
SpiderMonkey</p>

   </td>
  </tr>
  <tr>
   <td><p style="text-align: right">
Safari</p>

   </td>
   <td><p style="text-align: right">
JavaScriptCore(webkit)</p>

   </td>
  </tr>
  <tr>
   <td><p style="text-align: right">
Google Chrome</p>

   </td>
   <td><p style="text-align: right">
V8</p>

   </td>
  </tr>
</table>


<p dir="rtl">
البته کمپانی فیس‌بوک نیز موتوری با نام Hermes تولید نموده است تا بتواند عملکرد مناسب تری برای برنامه‌های موبایلی با فریم‌ورک[^2] ReactNative[^3] بر روی موبایل داشته باشد. در کل بدلیل گسترده بودن مطالب موتورهای مختلف js ، در این کتاب ، تنها موتور V8 گوگل را بررسی می‌کنیم چرا که هسته تولید برنامه‌های electron, nodejs و کدهای اجرا شده در کروم، این موتور است و یادگیری صحیح آن سهم بزرگی از برنامه‌نویسی به زبان جاواسکریپت را تحت تاثیر می‌گذارد.

<p dir="rtl">
<strong>موتور V8 کروم</strong></p>


<p dir="rtl">
این موتور متن باز ، توسط گوگل برای پروژه گوگل کروم و کرومیوم تولید شده است. نسخه اولیه v8 در 2 سپتامبر 2008 همزمان با نسخه اولیه نرم افزار کروم عرضه شد. این موتور که به زبان c++ توسعه داده شده است ، دارای پرفورمنس بالا برای اجرای جاواسکریپت و وب اسمبلی[^4] در زیر معماری موتور v8 را به صورت سطح بالا مشاهده می‌کنیم.

<p dir="rtl">


<p id="gdcalert1" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image1.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert2">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


<img src="images/image1.png" width="" alt="alt_text" title="image_tooltip">
</p>


<p dir="rtl">
در شکل فوق که از معماری و نحوه کارکرد موتور v8 توضیحات نسبتا کاملی ارائه می‌دهد ، می‌توان مسیر حرکت سورس کد js در مسیر تبدیل شدن به عملکرد اجرایی را مشاهده کرد ، در حقیقت شکل فوق را می‌توان به صورت فلوچارت زیر خلاصه سازی کرد.</p>


<p dir="rtl">


<p id="gdcalert2" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image2.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert3">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


<img src="images/image2.png" width="" alt="alt_text" title="image_tooltip">
</p>


<p dir="rtl">


<p id="gdcalert3" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image3.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert4">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


<img src="images/image3.png" width="" alt="alt_text" title="image_tooltip">
</p>


<p dir="rtl">
همانطور که گفته شد این موتور در ابتدا برای بهبود پرفورمنس اجرای کدهای جاواسکریپت در مرورگر طراحی شده بود و می‌توانست بجای ترجمه کدهای برنامه ، با تبدیل کدهای js به سطح بهینه‌تر و پایین‌تری از کد ماشین عملکرد بهتری را ارائه دهد. در شکل فوق مشاهده می‌کنیم سورس کد js ، از بالای نمودار مستقیما به تجزیه‌گر (parser) داده می‌شود. تجزیه‌گر بعد از دریافت کدهای برنامه ، درخت انتزاعی نحوی (AST)[^5] را تولید می‌کند. درخت AST ، درختی‌ست که از شروع اولین کد برنامه تا اجرای دستورات و عملیات‌های موجود در آن است که به موتور V8 کمک می‌کند ، کدهای نوشته شده را کاملا درک و برای انجام محاسبات آماده کند.

<p dir="rtl">
سپس مترجم سوئیچ[^6] ، bytecode مورد نیاز را تولید می‌کند و از طرفی دیگر کامپایلر TruboFan، کد ماشین بهینه سازی را تولید می‌کند ، دو فلش‌ تبادلی میانی نیز زمانی که کدهای بهینه‌سازی شده ماشین و Bytecode اجرا شدند، معنی پیدا می‌کنند. در ادامه توضیحات کامل‌تری از هر کدام از بخش های فلوچارت فوق را به شکلی دقیق‌تر مورد بررسی قرار می‌دهیم.

<p dir="rtl">
<strong>کارکرد تجزیه گر (parser)</strong></p>


<p dir="rtl">
مفهوم تجزیه کد ، به معنی ریز شدن برنامه به توکن های شناسایی شده[^7] می‌باشد، که در گام اول اجرای کد ، و پس از دانلود شدن آن انجام می‌شود. می‌توانیم توکن‌ها را الفبای زبان‌های برنامه‌نویسی بنامیم.

<p dir="rtl">
فرض کنید شما تکه کدی نوشته اید که وظیفه تعریف یک متغیر و مقداردهی آن با رشته hello world را برعهده دارد. به عبارتی دیگر شما تکه کد زیر را برای برنامه خود نوشته اید :</p>



```
var hi = "Hello World";
```


<p dir="rtl">
این تکه کد با ورود به چرخه موتور v8 در مرحله تجزیه ، به توکن‌های ("var" , "hi" , "=" , "Hello World") شکسته می‌شود تا در قالب گرامر زبان js قرار گیرد. حال با استفاده از این توکن‌ها که با گرامر زبان نیز بررسی و تطبیق داده شده‌اند ، درخت انتزاعی نحو AST ساخته می‌شود و scopeها معنی پیدا می‌کنند.</p>


<p dir="rtl">
<strong>کارکرد درخت تجزیه نحو (AST)</strong></p>


<p dir="rtl">
این درخت که حاصل توکن شدن تکه‌های کدهای برنامه است ، وظیفه دارد تا مشخص کند هر توکن چه نوع و مفهومی دارد و هر کدام در چه scopeای مورد استفاده قرار گرفته است. به معنای ساده‌تر این درخت یک ساختار داده برای معرفی کدهای برنامه است. یکی از وظایفی که در این درخت به وقوع می‌پیوندد، تشخیص scopeها و معنی دادن به متغیرهای داخل هر scope می‌باشد، بدین صورت که برای هر scope ، که از  scope اصلی برنامه شروع می‌شود ، به ازای هر تعریف متغیر ، در یک ساختار به اسم VariableDeclaration یک بخش برای آن متغیر در نظر گرفته می‌شود و بدین ترتیب مفهوم متغیرهای محلی و عمومی شکل می‌گیرد. حتی در مفهوم عمیق‌تر احتمالا closure‌ها را می‌توانید به یاد بیاورید و نحوه اجرای توابعی با متغیرهایی داخلی را در AST پیدا کنید.</p>


<p dir="rtl">
ابزارهای آنلاین برای مشاهده ساخته شدن AST را می‌توانید به سادگی در اینترنت پیدا کنید[^8] و برای کدهای خود ، ساخته شدن این درخت را مشاهده کنید. تکه کدی را در زیر مثال می‌زنیم و به شکلی کلی درباره AST ساخته شده برای‌ آن صحبت خواهیم نمود. تکه کد بسیار ساده زیر را در نظر بگیرید :


```
var hi = "hello" + "world";
```


<p dir="rtl">
کد فوق را با ابزار شبیه ساز AST ، شبیه سازی می‌کنیم :</p>


<p dir="rtl">


<p id="gdcalert4" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image4.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert5">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


<img src="images/image4.png" width="" alt="alt_text" title="image_tooltip">
</p>


<p dir="rtl">
در این تصویر مشاهده می‌کنیم که ابتدا برنامه و scope عمومی تشخیص داده شده و سپس بخش‌های تعریف متغیر و فرآیندهای متصل کردن رشته‌ها به همدیگر انجام شده است. اما در اصل یک Object درختی به صورت زیر ایجاد شده است : </p>



```
{
  "type": "Program",
  "start": 0,
  "end": 27,
  "body": [
    {
      "type": "VariableDeclaration",
      "start": 0,
      "end": 27,
      "declarations": [
        {
          "type": "VariableDeclarator",
          "start": 4,
          "end": 26,
          "id": {
            "type": "Identifier",
            "start": 4,
            "end": 6,
            "name": "hi"
          },
          "init": {
            "type": "BinaryExpression",
            "start": 9,
            "end": 26,
            "left": {
              "type": "Literal",
              "start": 9,
              "end": 16,
              "value": "hello",
              "raw": "\"hello\""
            },
            "operator": "+",
            "right": {
              "type": "Literal",
              "start": 19,
              "end": 26,
              "value": "world",
              "raw": "\"world\""
            }
          }
        }
      ],
      "kind": "var"
    }
  ],
  "sourceType": "module"
}
```


<p dir="rtl">
objectهای موجود دارای type, start, end, body و sourceType هستند که هر کدام مفهوم خاصی را به درخت می‌دهد. start شروع اولین کاراکتر و end محل آخرین کاراکتر مربوطه به کدهای مورد ارزیابی برای ساخت بخش را نمایش می‌دهد. body شامل تعاریف مربوط به کد می‌باشد که یک آرایه شامل یکسری object برای توصیف بخش‌های داخل بدنه کد است که چون ما فقط یک خط داریم که از نوع VariableDeclaration است ، در این بخش فقط یک Object قرار گرفته است.</p>


<p dir="rtl">
در مثال فوق بخش VariableDeclaration مشخص کننده شناساگر متغیر hi و مقدار آن در قالب init می‌باشد. در پایان نیز مقدار kind برابر با var است که می‌توانست let یا const نیز باشد. این مثال که فقط یک خط از کد برنامه را شامل می‌شد ، شکل بسیار ساده ای AST می‌باشد، که در حالت های پیشرفته کد ، توابع تودرتو ، closureها و … این درخت تا حدی پیچیده می‌شود. البته این پیچیده شدن بعضا نه فقط به لحاظ ساخته شدن ، بلکه به معنی زمان ساخته شدن این درخت نیز می‌باشد.</p>


<p dir="rtl">
<strong>عملکرد تجزیه گر در v8</strong></p>


<p dir="rtl">
در V8 برای تجزیه js دو حالت پیش تجزیه[^9] و تجزیه می‌تواند رخ دهد ، برای درک مفهوم کارکردی این دو مورد به مثال زیر توجه کنید :


```
function one() {
    console.log('function one called')
}

function two() {
    console.log('function two called')
}

/* Calling function one */
one()
```


<p dir="rtl">
در تکه کد بالا دو عدد تابع one و two تعریف شده و سپس تابع one فراخوانی شده است ، اما نحوه تجزیه شدن کد فوق به چه صورت است؟ ساده است ، تجزیه گر شروع به بررسی توکن‌ها و ساخت AST می‌کند و سپس کد اجرا می‌شود ، اما کمی صبر کنید … ما از تابع two استفاده نکرده‌ایم، چرا باید زمانی از برنامه را صرف تجزیه و ساخت AST و کامپایل آن تابع کنیم ؟ البته شاید بگویید ممکن است در بخشی دیگر مورد استفاده از برنامه این متد فراخوانی شده باشد ، اما قاعدتا موافق هستید که در شروع برنامه  و startup شدن نیازی به آن نیست . پس باید به نحوی این فرآیند اضافی را کنترل کنیم.</p>


<p dir="rtl">
در ابتدای پاراگراف گفتیم دو نوع تجزیه داریم ، منظور ما از <em>تجزیه</em> ، تمام فرآیندهای ذکر شده برای بدست آوردن توکن‌های برنامه و ساختن AST و خطاهای مربوطه است . اما <em>پیش تجزیه</em> مانند یک تجزیه‌گر سریع عمل می‌کند. پیش تجزیه‌گر تنها به تجزیه و کامپایل بخش‌های مورد نیاز در اجرای اولیه برنامه می‌پردازد و بدون ساختن AST ، خطاهای مربوطه و scope را مشخص می‌کند.</p>


<p dir="rtl">
فرض کنید یک تابع نوشته‌ایم و در داخل تابع از یک متغیر تعریف نشده استفاده کرده‌ایم ، مانند :</p>



```
function callMeGetError() {
    console.log('Hi , ' + user.name)
}

callMeGetError()   // Uncaught ReferenceError: user is not defined
```


<p dir="rtl">
می‌دانیم که این کد دارای خطا می‌باشد ، اما خطای موجود در آن ، تا زمانی که تابع مورد نظر صدا نشده است ، مشاهده نخواهد شد. دلیل این موضوع ، تجزیه نشدن تابع توسط V8 در هنگام اجرای اولیه کدها می‌باشد و در حقیقت ، منتظر مانده است تا تابع مورد نظر صدا زده شود و سپس تجزیه انجام شود.</p>


<p dir="rtl">
<strong>نحوه تجزیه closure</strong></p>



```
(function parent () {
    let one = 1
    let two = 2
    function child () {
        return one
    }
    return child
})
```


<p dir="rtl">
در کد فوق تابع parent ، به دلیل قرار گرفتن داخل بلوک IIFE ، در همان اجرای اولیه فراخوانی می‌شود. در تابع child که در scope داخلی تابع اصلی قرار گرفته است، از متغیری از scope بالاتر استفاده return شده است و همین موضوع باعث ایجاد وابستگی بین تابع فرزند و scope والد می‌شود. برای فراخوانی تابع child باید از حالت IIFE خارج شده و با ایجاد یک closure عادی و با فراخوانی پدر ، بتوانیم فرزند را فراخوانی کنیم.</p>



```
let childFn = parent()
childFn()    // 1
```


<p dir="rtl">
دریافت مقدار 1 از تابع child چندان عجیب به نظر نمی‌رسد ، اما v8 این مقدار را در چه مرحله‌ای از کد و چگونه مقداردهی می‌کند جالب است. در حقیقت ، هنگام تجزیه تابع child ، موتور v8 با مشاهده استفاده از متغیر one ، در context تابع فعلی به دنبال این متغیر می‌گردد و چون این متغیر را در context تابع داخلی مشاهده نمی‌کند به تابع پدر مراجعه می‌کند.</p>


<p dir="rtl">
به این طریق متغیر one در حافظه باقی می‌ماند و توسط Orinoco به عنوان garbage شناسایی نمی‌شود تا توسط متد داخلی مورد استفاده قرار گیرد . همین قضیه برای متدهای nested آبشاری نیز برقرار است و اگر با مفهوم innerClass در جاوا یا ruby و … آشنا باشید ، تقریبا رویکرد مشابهی در closure رخ می‌دهد.</p>


<p style="text-align: right">
<strong> JIT Compilation</strong></p>


<p dir="rtl">
در پاراگراف اول این فصل اشاره ای گذرا به کامپایل در لحظه داشتیم ، اما اگر با مفهوم کامپایل و تفسیر[^10] و تفاوت‌های این دو مورد آشنایی داشته باشید ممکن است _کامپایل در لحظه_ برایتان عجیب به نظر برسد. در حقیقت این عنوان به رویکردی در کامپایل شدن نسبت داده می‌شود که در آن تلاش شده است که برترین موارد موجود در سبک اجرای کد به وسیله تفسیر و کامپایل حفظ شود و روشی سریع‌تر برای اجرای کدهای برنامه ایجاد کند.

<p dir="rtl">
اگر مفهوم تقسیر شدن و اجرای خط به خط کدها را کنار بگذاریم ، رویکردها و استراتژی‌های متعددی برای کامپایل شدن کدها وجود دارد که  JIT Compilation نیز یکی از استراتژی‌های معروف است که در جاواسکریپت نیز مورد استفاده قرار می‌گیرد. در این سبک از کامپایل، سورس کدها در لحظه اجرای برنامه دریافت و به صورت موازی کامپایل می‌شوند و سورس کد برنامه به کد ماشین و bytecode تبدیل می‌شود. ایده اصلی پشت این سبک از کامپایل شدن ، پیشگیری از ترجمه مجدد کد تا حدامکان است که باعث بهبود سرعت اجرای برنامه در مقایسه با اجرای عادی آن می‌شود.</p>


<p dir="rtl">
در این رویکرد، کد به بخش های ولرم و داغ تقسیم می‌شود که این تقسیم شدن براساس میزان اجرای هر بخش از کد انجام می‌شود و این میزان اجرا شدن توسط یک پروفایلر به نام Ignition کدهای برنامه را تفسیر کرده و میزان اجرا شدن هر بخش از کد را تشخیص می‌دهد و به دو بخش کد گرم و کد داغ تقسیم می‌کند.. پس از تشخیص و جداسازی کدهای گرم و داغ، موتور  v8 می‌تواند تشخیص دهد که کدام بخش از کد به تمرکز بیشتری برای بهینه‌سازی نیاز دارد. به این ترتیب کدهای گرم(warm) برای اجرا به کامپایلر baseLine تحویل داده می‌شوند تا ادامه مسیر کامپایل و اجرا را طی کنند، اما کدهای داغ توسط optimizer که TurboFan نام دارد، براساس اطلاعات ارائه شده توسط مفسر بهینه‌سازی شده می‌شوند. بهینه‌سازی انجام شده در دو بخش بهبود مصرف حافظه و بهبود سرعت اجرا انجام می‌شود و البته این بهینه‌سازی و کامپایل به شیوه JIT تنها منحصر به v8 نیست و حتی به شیوه‌ای نسبتا پیچیده‌تر توسط webkit و توسط apple برای مرورگر safari انجام ‌شده است. به این شکل که به جای تقسیم بندی کد به دو بخش گرم و داغ، امکان اجرای کد به چهار شیوه مختلف وجود دارد :</p>




1. کامپایل نرمال توسط LLInt
2. کامپایل baseline
3. کامپایل با (Data Flow Diagram (DFG
4. کامپایل به شیوه (FTL (Faster than light

<p dir="rtl">
مدیریت اجرای کد میان این 4 کامپایلر براساس میزان اجرای هر تکه کد خواهد بود، برای مثال می‌توان دستور jsc را برای محیط command نصب کرد و با تنظیم کردن JSC_dumpDisassembly=true در env با اجرای کد‌های متفاوت ریز جزئیات نحوه اجرا شدن و استفاده از کامپایلرهای مختلف را مشاهده کرد.</p>


<p dir="rtl">
به صورت پیش‌فرض کدهای برنامه در کامپایلر نرمال و LLInt اجرا می‌شوند اما به طور مثال اگر jsc مشاهده کند که تابعی بیشتر از صد مرتبه اجرا می‌شود، اجرای آن را به baseline واگذار می‌کند و همینطور با ایجاد حلقه‌های بیشتر و چند هزار فراخوانی یک تابع مشاهده می‌شود که از FTL برای کامپایل کد استفاده می‌شود.</p>


<p dir="rtl">
<strong>جریان رخدادها (event loop)</strong></p>


<p dir="rtl">
اگر با چرخه کارکردی js آشنا باشید می‌دانیم که اصطلاحا جاواسکریپت به شکل تک thread کار می‌کند و یا به عبارت دیگر برنامه در هر لحظه تنها می‌تواند مشغول اجرای یک دستور باشد. اما با توجه به قابلیت‌هایی که از جاواسکریپت سراغ داریم و می‌دانیم توسط جاواسکریپت می‌توان کدهایی مانند setTimeout و یا درخواست‌های دیتا از سرور را انجام داد، شاید درک تک thread بودن آن کمی دشوار باشد.اما زمانی موضوع زمانی جالب می‌شود که سورس مربوط به موتور v8 را از اینترنت دریافت کرده و مطالعه کنید. موضوعی که احتمالا نظر شما را در وهله اول جلب می‌کند، این است که هیچ اثری از مواردی مانند setTimeout ، ajax ، DOM و … نیست! پس مرورگری مانند کروم که می‌گوییم با v8 کار می‌کند ، چگونه آنها را اجرا می‌کند!</p>


<p dir="rtl">
موضوع به WebAPI مربوط می‌شود، در حقیقت موتور جاواسکریپت و در کل زبان جاواسکریپت یک زبان جامع است که می‌تواند در جایگاه‌های مختلف کارایی داشته باشد. یکی از این جایگاه‌ها Web می‌باشد که در مرورگرها نیز علاوه بر موتورهای جاواسکرپیتی بخش‌های دیگری نیز برای مدیریت اجرای این زبان تعبیه می‌شود که WebAPIها نیز جزئی از آن هستند. در شکل زیر کلیات بخش‌های مورد استفاده برای اجرای js را مشاهده می‌کنیم :</p>


<p dir="rtl">


<p id="gdcalert5" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image5.jpg). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert6">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


<img src="images/image5.jpg" width="" alt="alt_text" title="image_tooltip">
</p>


<p dir="rtl">
همانگونه در که در شکل بالا مشاهده می‌کنیم موتور جاواسکریپتی v8 وظیفه مدیریت و اجرای کدهای زبان و به معنای دیگر مدیریت و کنترل heap و stack را برعهده دارد. زمانی که کدی از ویژگی‌ها و دستورات مجاز شده بواسطه محیط مرورگر(مانند DOM، Ajax یا دسترسی به منابع سیستم عامل) استفاده کنیم، اصطلاحا یک API دیگری به نام WebAPI را فراخوانی کرده‌ایم. برای مثال اگر در محیط  nodejs کدنویسی می‌کنیم، بجای بخش WebAPI در شکل فوق، یک API که توسط c++ نوشته شده است ما را در دسترسی به امکانات سیستم عامل و انجام امور مورد نظر یاری می‌کند. در مورد WebAPIها و نحوه کار آن‌ها به شکلی کامل‌تر در فصول بعد صحبت خواهد شد و تنها به معرفی کلی آن در این بخش بسنده می‌کنیم.</p>


<p dir="rtl">
با توجه به توضیحات داده شده و درک کارکرد WebAPIm، هنوز پاسخی برای سوال خود درباره نحوه کارکرد چند حالته زبان در کنار تک thread بودن آن نیافته‌ایم. اما در شکل فوق، علاوه بر بخش مربوط به APIها، بخشی دیگر نیز در پایین تصویر مشاهده می‌شود که event loop نام دارد که در کنار یک لیست به نام callback queue قرار گرفته است و در حقیقت همان بخش اسرارآمیز زبان نیز همین بخش است. اگر این بخش را به شکلی جدا از کل مکانیزم مطرح شده در شکل فوق مشاهده کنیم. وظیفه این بخش بررسی مداوم صف متدهای callback و وارد کردن آن متدها به stack می‌باشد. انجام مداوم این‌کار باعث می‌شود هر تسکی که وارد صف انتظار می‌شود در صورتی که stack خالی شود، وارد stack شده و توسط v8 اجرا می‌شود پس event loop مانند یک مامور بالای سرسره آبی وظیفه دارد هنگامی که سرسره خالی شد اجازه دهد نفر بعدی از صف وارد سرسره شود. برای مثال اگر برای برنامه‌ای پس از یک تعداد خط کد از setTimeout استفاده کنیم، چون می‌دانیم stack توسط v8 به شکل مداوم و به حالت [^11]‌LIFO خالی می‌شود، پس وقتی تمام کد‌های stack خالی شدند(که در صورت async[^12] بودن کدهای برنامه، سریع انجام می‌شود) ، می‌توانیم مطمئن باشیم که event loop ، تابع callback ارائه شده در setTimeout را در زمانی که به عنوان delay به این تابع داده‌ایم(تقریبا)[^13] فراخوانی خواهد کرد. 

<p dir="rtl">
<strong>همزمانی(concurrency)</strong></p>


<p dir="rtl">
همزمانی یا concurrent mode به حالتی گفته می‌شود که برنامه قابلیت اجرای چندین قطعه کد را به صورت یکجا داشته باشد. مثلا تصور کنید یک درخواست دریافت اطلاعات از API به شکل rest  توسط برنامه ارسال شده است، اما همزمان بخشی دیگر از برنامه مشغول عملیات دیگری‌ست و منتظر دریافت نتیجه درخواست API  نمانده است، یا اگر برنامه به شکلی باشد که نیاز به دیتای درخواست API در بخشی از صفحه وجود داشته باشد از skeleton یا loading برای آن بخش خاص استفاده می‌شود. به این ترتیب کاربر احساس بلاک بودن صفحه تا زمان کامل شدن نتیجه درخواست را نخواهد داشت. با از درک ماهیت کارکردی موتورهای جاواسکریپت و نحوه کارکرد event loop می‌دانیم که انجام اینگونه عملیات‌ها در جاواسکریپت میسر می‌باشد و اگر از این قابلیت در برنامه‌های طراحی شده خود استفاده نکنیم در واقع ضعف طراحی برنامه خود ما می‌باشد و زبان این قابلیت را پشتیبانی می‌کند.</p>


<p dir="rtl">
در فریم‌ورک‌ها و کتابخانه‌های مشهور نیز تمام تلاش بر استفاده از حالت concurrent و همزمانی بیشتر برنامه‌ها انجام می‌شود، اما  بخاطر پیچیدگی منطق‌های حاکم بر برنامه در سطح برنامه‌های سازمانی و بزرگ، استفاده صحیح از این قابلیت کمی دشوار است که راه‌حل‌های مختلفی توسط فریم‌ورک‌های مشهور همواره ارائه می‌شود. مثال اینگونه موارد می‌تواند suspense، progressive hydration، lazyLoad و… باشد که در سال‌های اخیر نیز توجه به سزایی توسط توسعه‌دهندگان به آنها شده است.</p>


<p dir="rtl">
<strong>کارکرد async/await و رابطه آن با callback</strong></p>


<p dir="rtl">
با درک نحوه کارکرد موتور v8 برای اجرای کدهای برنامه، درک نحوه اجرا شدن promiseها و async/await در موتور v8 می‌توان حدس زد که این عبارات نیز ناگزیر می‌بایست در قالب توابعی در event loop مدیریت شوند، با توجه به اینکه async/await نیز تنها برای راحتی استفاده از promise بوجود آمده است می‌توان هر دو مورد promise و async/await را در یک گروه مورد بررسی قرار داد.</p>


<p dir="rtl">
با توجه به عملکرد تک threadی در جاواسکریپت عملیات‌های asynchronous در قالب یک حلقه از رخداد‌ها انجام می‌شوند و عملکردی asynchronous را برای برنامه ایجاد می‌کنند. با توجه به این توصیف می‌توان متوجه اجرای آن به شکل callback شد. قبل از عمیق شدن در بحث اجازه دهید کمی ساختار و کارکرد کدهای async/await را بررسی کنیم.</p>


<p dir="rtl">
<strong>توابع async</strong></p>


<p dir="rtl">
با قرار دادن کلمه کلیدی async قبل از نام هر تابع جاواسکریپت مقدار بازگشتی آن را یک promise تلقی می‌کند و اگر مقدار بازگشتی promise نباشد به عنوان یک promise که solve شده است بازگشت داده می‌شود. برای مثال حتی می‌توان تکه کدی به شکل زیر نوشت: </p>



```
async function f() {
  return 1;
}

f().then(alert); // 1
```


<p dir="rtl">
با توجه به اینکه تابع f مقداری عددی باز می‌گرداند و مقدار عددی promise نیست با نوشتن .then در هنگام فراخوانی آن برنامه به گونه‌ای اجرا می‌شود که گویی تابع ‌f یک promise بوده که solve شده و مقدار یک را بازگشت داده است.</p>


<p dir="rtl">
<strong>عبارات await</strong></p>


<p dir="rtl">
برای استفاده از این promiseها نیز به جای نوشتن زنجیره‌ای .then می‌توان با نوشتن کلمه کلیدی await قبل از یک promise به برنامه دستور منتظر ماندن برای اجرای مابقی خط از کدها را داد. به این صورت که اگر یک تابع async یا به شکلی عادی یک promise داشته باشیم می‌توانیم دستور await را برای آن بنویسیم. نکته‌ای که برای نوشتن کلمه کلیدی await وجود دارد این است که می‌بایست این کلمه کلیدی را داخل یک scope از تابعی async بنویسیم و مجاز به استفاده از آن در scope عمومی نیز نیستیم، چرا که scope عمومی async نیست. به مثال زیر در این خصوص توجه کنید :</p>



```
(async function(){
  let promise = new Promise((resolve, reject) => {
    setTimeout(() => resolve("done!"), 1000)
  });

  let result = await promise; // wait until the promise resolves (*)

  alert(result); // "done!"
})();
```


<p dir="rtl">
 نکته گفته شده درمورد استفاده از await در این مثال رعایت شده است و برای اینکه در scope عمومی بتوانیم await استفاده کنیم، یک عبارت IIFE قرار داده و در داخل آن await را استفاده کرده‌ایم. برای ساخت promise نیز یک setTimeout را داخل کلاس Promise قرار داده و پس از یک تایم مشخص resolve می‌کنیم.  از await می‌توان برای اجرای هر کلاسی که متد then را implement کرده باشد استفاده کرد. به این صورت که یک کلاس مثلا با عنوان thenable خواهیم داشت که مشابه promise عمل می‌کند ولی promise نیست. در این کلاس متد then می‌بایست به شکل داخلی نوشته شده باشد. برای مثال:</p>



```
class Thenable {
  constructor(num) {
    this.num = num;
  }
  then(resolve, reject) {
    alert(resolve);
    // resolve with this.num*2 after 1000ms
    setTimeout(() => resolve(this.num * 2), 1000); // (*)
  }
};
```


<p dir="rtl">
این کلاس به لحاظ منطقی promise نیست اما عملکردی دقیقا مشابه promise دارد. با new کردن این کلاس و await شدن روی آن می‌توان انتظار فراخوانی متد then مقدار مورد انتظار پس از گذشت میزان delay تعیین شده بود.</p>



```
async function f() {
  // waits for 1 second, then result becomes 2
  let result = await new Thenable(1);
  alert(result);
}

f();
```


<p dir="rtl">
 در مثال بالا از کلاس thenable ایجاد شده خود، همانند promise استفاده کرد. مشاهده این کلاس برای درک اجرای async/await در v8 کمک زیادی خواهد کرد، چرا که تقریبا از ساختار داخلی promiseها آگاه شده‌ایم و نحوه کار‌ آن‌ها را با کلاس thenable شبیه‌سازی کرده ایم و مابقی عملیات همان setTimeout است که در بخش مربوط به اجرای concurrent کدها بررسی کرده‌ایم.</p>


<p dir="rtl">
پس می‌توان نتیجه‌گیری کلی به شکل زیر را از کلیات موارد بحث شده به شکل زیر برآورد کرد، با قراردادن کلمات کلیدی  async/await در بخشی از برنامه، اگر تابع async فراخوانی شده،  promise بازگشت دهد. برنامه با مشاهده await تا زمان اتمام promise و خارج شدن از حالت pending منتظر می‌ماند. ولی اگر مقدار بازگشتی تابع promise نباشد، برنامه مانند یک promise که solve شده است مابقی کدهای برنامه را اجرا می‌کند. با فرض promise بودن مقدار بازگشتی تابع async که یک thenable است، متد then آن اجرا می‌شود و اگر فرض کنیم عملیات async مورد نظر ما برای اجرای setTimeout باشد، به سادگی می‌توان تابع callback را مشاهده کرد و اجرا شدن آن در eventloop را متصور شد. دیگر حالت‌های هر عملیات async را نیز می‌توان با فراخوانی تابع callback پس از اتمام عملیات مورد نظر شبیه‌سازی کرد.</p>


<p dir="rtl">
<strong>جایگاه nodejs</strong></p>


<p dir="rtl">
یکی از خوشایندترین و موردنیازترین رخدادهایی که در دنیای جاواسکریپت انجام شد، ایجاد nodejs در سال 2009 بود. تحول بزرگ دیگر بواسطه npm در سال 2010 و یکسال پس از انتشار اولین نسخه nodejs رخ داد. این تغییر بزرگ بخاطر مدیریت کننده پکیج npm برای دسترسی راحت‌تر به پکیج‌های node بود که به سرعت برای برنامه‌نویسی سمت frontend نیز مورد استفاده قرار گرفت. فارغ از تحولاتی که به واسطه node برای جاواسکریپت ایجاد شد، اگر بخواهیم تعریف خاص nodejs را مطالعه کنیم، مشاهده می‌کنیم که ویکی پدیا تعریفی به شکل زیر ارائه نموده است :</p>


<p dir="rtl">
<em>'nodejs یک محیط اجرایی متن باز برای اجرای جاواسکریپت است که کدهای جاواسکریپت را خارج از مرورگر اجرا می‌کند. nodejs به برنامه‌نویسان اجازه می‌دهد تا برنامه‌های جاواسکریپتی را برای اجرا در محیط cmd یا تحت سرور توسعه دهند.'</em></p>


<p dir="rtl">
 این تعریف بسیار هیجان‌انگیز است، چون تقریبا با این تعریف می‌توان به مفهوم 'جاواسکریپت در همه‌جا' رسید.  اما این امکان چگونه توسط node ارائه می‌شود؟ چرا پکیج‌های npm را در برنامه‌نویسی فرانت‌اند نیز می‌توان استفاده کرد؟</p>


<p dir="rtl">
قبل از پاسخ به این سوالات یک بیشینه تاریخی در مورد nodejs را مطالعه کنیم. در ابتدا nodejs فقط برای اجرا بر روی سیستم عامل‌های مک و لینوکس و توسط RayanDahl ساخته شده بود و توسط کمپانی Joyent حمایت می‌شد. نسخه اولیه ترکیبی از v8 ، event loop و یک پردازشگر سطح پایین برای عملیات ورودی/خروجی(I/O) بود. سپس یکسال پس از ساخته شدن npm و در سال 2011 ، کمپانی مایکروسافت و Joyent نسخه ویندوز nodejs را نیز تولید و منتشر کردند. در سال 2014 کمپانی Fedor یک نسخه Fork از nodejs را با عنوان io.js برای بروزرسانی مداوم‌تر و هماهنگی بیشتر با موتور v8 گوگل داشته باشند اما این جدایی و دوگانگی یکسال بیشتر طول نکشید و در سال 2015 این دو نسخه با هم رای کمیته‌های خود به ترکیب nodejs و io.js برای ادامه فعالیت تحت عنوان nodejs با هم ترکیب شده و امکانات es6 موتور v8 را تحت عنوان نسخه چهار nodejs منتشر کردند. در ماه می سال 2018 توسعه‌دهنده اصلی nodejs، ‌آقای Dahl محیطی به نام Deno معرفی کرد که نسخه TypeScript شده nodejs بود و به زبان Rust توسعه داده شده بود.</p>


<p dir="rtl">
این چکش کاری‌های انجام شده در طول چندین سال باعث تولید بدنه‌ای پایدار برای nodejs شده است که توسط فریم‌ورک‌ها و کتابخانه متعددی مورد استفاده قرار می‌گیرد. نمونه‌هایی مانند express.js ، SocketIO، Meteor ، sails.js و … ابزارهای مشهوری هستند که به توسعه nodejs کمک می‌کنند. حال به سوالات مطرح شده در ابتدای بحث برمیگردیم چرا که هدف این کتاب عمیق شدن در جاواسکریپت بوده و nodejs به جهت معرفی ابزارها ارائه شده است.</p>


<p dir="rtl">
با درک اینکه nodejs نیز در هسته خود از v8 برای اجرای جاواسکریپت اجرا می‌کند، می‌توان اجرای کدها به شکل concurrent و در یک حلقه از درخواست‌ها را نتیجه گرفت. به لحاظ اجرایی نیز تقریبا مشابه عملیاتی که برای اجرای کدهای جاواسکریپت در مرورگر انجام می‌شود در nodejs رخ می‌دهد. با این تفاوت که عملیات‌های ورودی و خروجی دیتا در مرورگر و محیط nodejs بوده و  در سیستم‌عامل‌های مختلف متفاوت است. برای این منظور nodejs از libuv استفاده می‌کند که یک thread pool برای خواندن و نوشتن دیتا به شکل async را فراهم می‌کند. در Deno آقای Dahl بجای libuv از یک کتابخانه دیگر به اسم Tokio استفاده کرده است که از کامپایلرهای تایپ‌سکریپت استفاده می‌کند.</p>


<p dir="rtl">
تصور کنید مسئولیتی برای طراحی یک برنامه که فارغ از محیط مرورگر و درمحیط ماشین انجام شود به شما داده شده است و به دلیل داینامیک بودن جاواسکریپت و سادگی آن برای طراحی برنامه، می‌خواهید از این زبان برای انجام کار خود استفاده کنید. نیازمندی‌های شما برای برنامه خود در محیط ماشین چه چیزهایی می‌تواند باشد؟ ممکن است پیشنهاد بدهید nodejs را نصب می‌کنیم و به سادگی از اجرای برنامه خود خوشحال می‌شویم یا شاید حرفه‌ای تر باشید و بگویید با docker و ci/cd و … همین کار را می‌کنیم،  حتی ممکن است پیشنهاد دهید v8 را نصب کرده و استفاده کنیم. اما هر کدام از این راهکارها مشکلات خود را دارند… برای مثال در nodejs نمی‌توان دسترسی برنامه به بخش‌های مختلف سخت‌افزار را کنترل کرد و ممکن  است برنامه ساده‌ای که می‌خواستیم یک عملیات cron job بر روی یک سری دیتای متنی موجود روی هارد دیسک را انجام دهد، کنترل network را بدست گیرد. حتی استفاده از v8 نیز به سادگی انجام نمی‌شود چرا که مانند nodejs دارای libuv نیست که بتواند شبیه‌سازی thread را در محیط node ممکن کند بعلاوه خود v8 سختی‌های خود را برای انجام برنامه‌نویسی خام با آن دارد. با توجه به پیشرفت‌های جاواسکریپت و نیازهای روزمره به اجرای آن در محیط‌هایی خارج از مرورگر، انتظار می‌رود ممکن است آینده جاواسکریپت با ابزارهایی متفاوت‌تر و خاص منظوره‌تر عجین شود. ابزارهایی که امکان اجرای برنامه به صورت embeded یا native برای یک پلتفرم خاص را فراهم می‌کنند. ممکن است این آینده با React و Electron و Deno تلفیق شده باشد.</p>


<p dir="rtl">
</p>


<p dir="rtl">
<strong>پس از مطالعه این فصل انتظار می رود </strong></p>




*   مورد اول
*   مورد دوم
*   مورد سوم
*   مورد چهارم

<p dir="rtl">
 \
</p>



<!-- Footnotes themselves at the bottom. -->
## Notes

[^1]:
<p>
     https://en.wikipedia.org/wiki/JavaScript_engine</p>


[^2]:
<p>
    <p dir="rtl">
 یک قالب کاری مشخص که برای سهولت و بهبود کار با یک زبان خاص ایجاد می شود</p>


[^3]:
    <p dir="rtl">
 فریم‌ورکی برای تولید برنامه‌های موبایلی با استفاده از جاواسکریپت </p>


[^4]:
<p>
     Web Assembly</p>


[^5]:
<p>
     Abstract Syntax Tree</p>


[^6]:
<p>
     interpreter ignition</p>


[^7]:
<p>
     tokenize</p>


[^8]:
<p>
     https://astexplorer.net</p>


[^9]:
<p>
     pre-parse</p>


[^10]:
<p>
     interpret</p>


[^11]:
<p>
    <p dir="rtl">
 مختصر شده Last Input First Output و برعکس صف عمل می‌کتد.</p>


[^12]:
    <p dir="rtl">
 تعریف جامع برای async را در پاراگراف‌های بعدی این فصل مطالعه می‌کنید، در کل کدهایی که به صورت همزمان و بدون وقفه برای اجرای تکه کد جاری و زمان‌بر انجام می‌شوند.</p>


[^13]:
    <p dir="rtl">
 استفاده از واژه نقریبا به این دلیل است که زمان ارائه شده delay به متد setTimeout، حداقل زمان لازم برای اجرا است و الزاما اجرای متد پس از آن زمان را تضمین نمی‌کند، چرا که اگر صف متد‌های دیگر قبل از این متد پر باشد ممکن است با اختلاف زیادی برای اجرا مواجه شود. برای اجرای در لحظه متد می‌توان از setImmediate استفاده کرد که تنها به عملیات‌های I/O می‌ماند</p>

