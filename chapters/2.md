<p dir="rtl">
فصل دوم</p>


<p dir="rtl">
 </p>


<p dir="rtl">
<strong>خطایابی، تست و کدنویسی تمیز</strong></p>




*   اهداف فصل :‌ 
    *   هدف یک
    *   هدف دو 
    *   هدف سه
    *   هدف چهار
    *   هدف پنج
    *   هدف شش

<p dir="rtl">
</p>


<p dir="rtl">


<p id="gdcalert1" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image1.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert2">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


<img src="images/image1.png" width="" alt="alt_text" title="image_tooltip">
</p>


<p dir="rtl">
<strong>خطایابی</strong></p>


<p dir="rtl">
در هنگام برنامه‌نویسی با هر زبان یکی از اصلی‌ترین و روتین‌ترین رخدادها، بروز خطا در برنامه است. وظیفه ما به عنوان برنامه‌نویس این است که بتوانیم به بهترین و سریعترین شکل ممکن محل رخداد خطا را پیدا کرده و آن را رفع کنیم. برای آشنا شدن بیشتر با خطایابی، ابتدا تعریف خطا یا باگ را مطالعه می‌کنیم. باگ چیست؟‌ در تعریف ویکی‌پدیا درباره باگ می‌خوانیم:</p>



    <p dir="rtl">
<em>"یک خطا ، عیب یا نقص در یک برنامه یا سیستم رایانه ای است که باعث می شود نتیجه نادرست یا غیر منتظره حاصل شود و یا به شیوه های ناخواسته رفتار کند."</em></p>


<p dir="rtl">
با توجه به این تعریف برخلاف تصور برخی از برنامه‌نویسان تازه‌کار ، در برخی موارد اتفاقا رفع خطا می‌تواند سخت‌تر از اجرای آن برنامه باشد. پس نیاز هست برنامه‌های طراحی شده از پترن‌های مشهور برنامه‌نویسی پیروی کنند تا طرز تفکر برای نوشتن کد، بین توسعه‌دهندگان مختلف تا حدامکان مشترک بوده و رفع خطا به سادگی انجام شود. با فرض اینکه در طراحی برنامه تاثیری نداشته‌ایم و وظیفه خطایابی آن برعهده ماست، در این بخش سعی می‌کنیم به بهترین شکل ممکن خطای موجود در برنامه‌ها را شناسایی رفع کنیم.</p>


<p dir="rtl">
<strong>استفاده از console</strong></p>


<p dir="rtl">
یکی از ساده‌ترین روش‌ها و در عین حال مرسوم‌ترین آنها استفاده از console برای چاپ یک مقدار شخص در کنسول استاندارد سیستم می‌باشد که هم در محیط مرورگر و هم در محیط‌های غیر مرورگری و حتی در محیط worker نیز کاربرد دارد. با استفاده از کنسول می‌توان مقدار یک متغیر را مشاهده کرده و یا از رسیدن اجرای کامپایلر به بخشی مشخص از برنامه اطمینان حاصل کرد.</p>


<p dir="rtl">
برای استفاده از محیط کنسول در مرورگر، مرورگرهای مختلف شیوه‌های مختلفی را دنبال می‌کردند، فعال‌سازی تب console از تنظیمات برای نمایش منوی کنسول در بخش developer tools شیوه‌ای بود که کروم برای انجام اینکار داشت. فایرفاکس ابزاری نسبتا کامل با عنوان نرم‌افزار firebug را به شکلی جدا از فایرفاکس، از سال 2009 تا سال 2017 توسعه می‌داد. اما پس از آن با انتشار نسخه developer mode این مرورگر، ابزارهای موجود در این نرم‌افزار را در مرورگری مجزا در اختیار برنامه‌نویسان قرار داد. در این بخش می‌خواهیم با فراخوانی متد‌های مختلف شي console برنامه خود را debug کرده و انواع متد‌های کاربردی و کاربردشان را در بررسی می‌کنیم.</p>




*   **متد log : **مشهورترین متد console، متد log است که با فراخوانی آن می‌توان یک مقادیر مختلف را در کنسول نمایش داد. البته این متد نیز یکسری پارامتر‌ها و ترفندهای خاص برای نمایش خاص‌تر یک پیام را دارد. برای مثال می‌توان یک پترن تعیین کرد و یک متن با template مشخص را تولید کرد. برای مثال:

    ```
for (var i=0; i<5; i++) {
    console.log("Hello, %s. %d call", "Name", i+1);
}
```



<p dir="rtl">
در مثال فوق به %s و %d به ترتیب جایگاه‌هایی برای قرارگیری مقادیر رشته‌ای و عددی می‌باشند که در ادامه به عنوان پارامتر به این متد داده شده‌اند. می‌توان با استفاده از این سبک متغیر‌ها و قراردهی %o مقادیر object نیز در کنسول چاپ کرد که قابلیت  expand شدن با کلیک موس را دارند.</p>


<p dir="rtl">
به همین سبک می‌توان به مقدار چاپ شده در کنسول را با دستورات css استایل دهی کرد و به مقدار چاپ شده در کنسول ویژگی‌های css قابل استفاده در محیط کنسول را داد. این ویژگی‌ها تقریبا 20 مورد می‌باشد که بر روی متن و حاشیه و رنگ تاثیر می‌گدارند. مثال مشهور این مورد استایل‌دهی در سایت فیس‌بوک قابل مشاهده است که برای جلوگیری از حمله‌های امنیتی که برای کاربران قرار گرفته است. </p>


<p dir="rtl">


<p id="gdcalert2" ><span style="color: red; font-weight: bold">>>>>>  gd2md-html alert: inline image link here (to images/image2.png). Store image on your image server and adjust path/filename/extension if necessary. </span><br>(<a href="#">Back to top</a>)(<a href="#gdcalert3">Next alert</a>)<br><span style="color: red; font-weight: bold">>>>>> </span></p>


<img src="images/image2.png" width="" alt="alt_text" title="image_tooltip">
</p>


<p dir="rtl">
برای مثال:‌</p>



```
console.log("This is %cMy stylish message", "color: yellow; font-style: italic; background-color: blue;padding: 2px");
```


<p dir="rtl">
این مثال یک متن زرد رنگ به صورت کج و با رنگ پس‌زمینه آبی در کنسول نمایش می‌دهد.</p>


 

<p dir="rtl">
نکته مهم دیگر در مورد کنسول کردن objectهاست، به دلیل اینکه در جاواسکریپت objectها muttable هستند. هنگام کنسول کردن آن‌ها اگر به شکل عادی عنوان متغیر را کنسول کنیم، با تغییرات در آن object مقدار چاپ شده نیز به روز می‌شود و ممکن است مقداری اشتباه چاپ شود. اما اگر بجای چاپ خود متغیر یک کپی از آن را در هنگام نیاز به چاپ شدن، کنسول کنیم. مقدار بدست آمده مقداری صحیح خواهد بود. برای مثال:</p>



```
const sampleObj = {a: 2};
console.log(JSON.parse(JSON.stringify(sampleObj)));
```




*   **متد table : **احتمالا بعد از log معروف‌ترین متد، table باشد که همانند متد log یک متغیر را در خروجی چاپ می‌کند. اما تفاوت در این است که این متد با دریافت یک لیست که ممکن است آرایه، ‌object یا در مفهوم کلی متغیری tabular باشد را در یک جدول نمایش ‌می‌دهد.

    ```
console.table(["apples", "oranges", "bananas"]);

var people = [["John", "Smith"], ["Jane", "Doe"], ["Emily", "Jones"]];
console.table(people);
```



<p dir="rtl">
تکه کدهای بالا را اگر در کنسول مرورگر کپی کنید نتیجه اجرای آن‌ها تولید جداولی خواهد بود که بر اساس داده‌های ارائه شده در کنسول چاپ می‌شوند.</p>




*   **متدهای warn , error و info : **این متد‌ها عملیاتی مشابه log کردن را انجام می‌دهند، با این تفاوت که نوع خروجی آنها مشخص است و در خروجی نیز با ظاهری متفاوت و درخور نوع خود نمایش داده می‌شوند.
*   **متد trace :** این متد برای نمایش مسیر اجرای کد‌های برنامه تا رسیدن به این بخش از کد را در کنسول نمایش می‌دهد. برای مثال :

    ```
function foo() {
    function bar() {
        console.trace();
    }
    bar();
}

foo(); 

/* 
  VM5232:3 console.trace
  bar @ VM5232:3
  foo @ VM5232:5
  (anonymous) @ VM5232:8
*/
```



<p dir="rtl">
با فراخوانی تکه‌کد بالا به ترتیب  توابع foo و bar اجرا می‌شوند و با مشاهده متد trace از کنسول مسیر حرکتی کد تا به این متد را در خروجی به شکلی مشابه خطوط آخر تکه کد بالا نمایش می‌دهد.</p>




*   **متد count : **این متد، با چاپ تعداد دفعاتی که یک بخش از کد اجرا شده است، می‌تواند ما را در دیباگ خطاهایی که با مشکل اجرا شدن بیش از تعداد مورد نظر مواجه هستند، کمک کند. ورودی این متد یک کلید است که تعداد شمارش برای آن کلید منحصر به فرد انجام می‌شود. برای مثال:

    ```
function sayWelcome(name = 'ali') {
  console.count(user);
  return "Hello, " + user;
}

sayWelcome();
sayWelcome("mohammad");
sayWelcome("mohammad");
console.count("mohammad");
```



<p dir="rtl">
خروجی کد فوق به شکل زیر خواهد بود :</p>



```
"ali: 1"
"mohammad: 1"
"mohammad: 2"
"mohammad: 3"
```


<p dir="rtl">
نکته در خط آخر فراخوانی است که متد count مستقیم و بیرون از تابع sayWelcome نوشته شده است اما شمارش برای mohammad انجام شده است. با مشاهده این بخش احتمالا به سادگی بتوان نحوه ‌کار این متد را حدس زد، چرا که شمارش برای یک ورودی مشخص انجام می‌شود و اگر ورودی داده نشود، شمارش برای کلیدی با عنوان default انجام می‌شود. شمارش این متد را می‌توان با فراخوانی countReset با همان label ریست کرد.</p>



```
console.count();    // default: 1
console.count();    // default: 2
console.count();    // default: 3

console.countReset();
console.count();    // default: 1
```




*   **متد ‌time :** اگر عملیاتی داریم که می‌خواهیم میزان زمان سپری شده تا انجام شدن آن را در داخل کنسول اندازه‌گیری کنیم. عملکرد این متد نیز مشابه متد count است و با دریافت یک label شمارش را برای آن شناسه خاص شروع می‌کند. برای مشاهده میزان زمان سپری شده می‌توان از متد timeLog با ورودی label مشخص استفاده کرد. برای اتمام اندازه‌گیری زمان نیز می‌توان با فراخوانی متد timeEnd اندازه‌گیری زمان را متوقف نمود. برای مثال :

    ```
console.time("jsTestTime");
alert("Just time killer alert :)");
console.timeLog("jsTestTime");
alert("We want more time killing...");
console.timeEnd("jsTestTime");
```



<p dir="rtl">
در این تکه کد یک تایمر با عنوان jsTestTimer ایجاد کرده‌ایم. با فراخوانی تابع alert می‌خواهیم یک زمان شبیه‌سازی شده از انجام عملیات توسط کاربر را ایجاد کنیم. (چرا که باید بر روی دکمه ok کلیک شود تا خط کد بعدی اجرا شود.) سپس یک log از زمان سپری شده تا این بخش را چاپ کرده و دوباره سعی می‌کنیم شبیه‌سازی رفتار فرد را ایجاد و در آخر زمان اصلی سپری شده تا این بخش را چاپ کرده و تایمر را متوقف کنیم.</p>




*   **متد clear :** ممکن است در بخشی از برنامه بخواهیم شرطی را بررسی کرده و سپس بر اساس نتیجه شرط تصمیم بگیریم که پیامی را برای دیباگ چاپ کنیم. برای این منظور می‌توانیم یک بلاک if نوشته و متد console.log را فراخوانی کنیم. اما به سادگی می‌توانیم از متد assert استفاده کنیم. به این شکل که پارامتر اول را شرط مورد نظر برای بررسی شدن و پارامتر دوم را دیتای مورد نظر برای log شدن قرار می‌دهیم. اگر نتیجه شرط **false** باشد، عبارت مورد نظر در خروجی نمایش داده می‌شود ولی اگر نتیجه assert ، true باشد هیچ اتفاقی در کنسول رخ نمی‌دهد. مثال: 

    ```
console.assert(true, {foo: 'bar'});
console.assert(false, {foo: 'bar'}); 
/*
VM8287:1 Assertion failed: { foo: 'bar'}
*/
```


*   **متد group :** این متد برای ساخت گروه‌هایی از لاگ‌ها می‌باشد که به صورت سری با فراخوانی آن می‌توان indent یا تورفتگی ایجاد کرد.

    ```
console.log("before level start");

// start group-1
console.group();
console.log("Level-1");

// start group-2
console.group();
console.log("Level-2");
console.error("Error in level-2");

// end group-2
console.groupEnd();

console.log("In level-1");
// end level-1
console.groupEnd();

console.log("Normal console.log");
```


*   **متد clear :** این متد تمام عبارات چاپ شده در کنسول را خالی می‌کند. البته کارکرد صحیح این متد نیاز به انتخاب نشدن preserve log در بخش تنظیمات دارد.

<p dir="rtl">
 </p>


<p dir="rtl">
<strong>کلمه کلیدی debugger و break point</strong></p>


<p dir="rtl">
با شناخت console و کاربردهای مناسب آن در محیط‌های مرورگر و غیر مرورگری، می‌توانیم یکسری از ایراداتی که برای دیباگ کردن دارد را نام ببریم. این ایرادات عبارتند از: محدودیت در نمایش مقادیر و متغیرها در کنسول، سخت بودن نوشتن هر متغیر در کنسول، عدم امکان اجرای مجدد برنامه در لحظه دیباگ و … . تمامی این موارد ضرورت وجود ابزاری دیگر برای انجام دیباگ را تایید می‌کند و در حقیقت سازندگان زبان پیش‌تر به این موارد فکر کرده و break point یا نقطه انفصال را به زبان اضافه کرده‌اند.</p>


<p dir="rtl">
در این روش بجای فراخوانی متدهای کنسول، با قرار دادن کلمه کلیدی deugger در خط مورد نظر از برنامه، مرورگر با رسیدن به خط مورد نظر، تمام متغیرهای جاری در  stack برنامه، به همراه scope و امکان ادامه اجرای برنامه به روش خط به خط یا پرشی را فراهم می‌کند. بدین ترتیب می‌توان بجای تغییر عبارت کنسول به ازای هر تغییر در دیباگ برنامه، با قرار دادن یک کلمه کلیدی debugger در بخشی مناسب با اجرای برنامه به سادگی تمام اهداف مورد نظر برای دیباگ را انجام داد، چراکه اکثرا هدف از دیباگ، حصول اطمینان از پرشدن یک متغیر خاص، اجرای یک کد در scope مشخص و فراخوانی شدن متد‌های مورد انتظار می‌باشد. حال این انتظارات اگر قابلیت اجرا شدن خط به خط و مشاهده‌ زنده نحوه تغییر شدن هر متغیر در خط جاری را نشان دهد، فرآیند دیباگ بسیار ساده‌تری را می‌توان انتظار داشت. مثال :</p>



```
var x = 15 * 5;
debugger;
document.getElementById("demo").innerHTML = x;
```


<p dir="rtl">
<strong>کدنویسی تمیز</strong></p>


<p dir="rtl">
مفهوم clean code یا کدنویسی تمیز استانداری بسیار بزرگ و تحولی چشم‌گیر در فرآیند تولید نرم‌افزار ایجاد کرد بواسطه تلاش‌های آقای رابرت مارتین و کتاب مشهور clean code وی به عرصه توسعه نرم‌افزار اضافه شد. این استاندارد که قوانین مشخص و متعددی برای نحوه کدنویسی ارائه می‌دهد برای اکثر زبان‌های برنامه‌نویسی تدوین شده است. این مجموعه اصول به شما کمک می کند کدی بنویسید، که فهم و اصلاح آن توسط دیگران و یا بعد از مدت های طولانی برای خودتان سخت نباشد. تفاوت برنامه‌نویس‌های میان رده و حرفه‌ای در نحوه کدنویسی آن‌ها مشخص می‌شود و منظور از نحوه کدنویسی در وحله اول رعایت یا عدم رعایت اصول clean code می‌باشد. وجه مقابل کد تمیز ، کد کثیف(dirty code) است که دیباگ و بهبود کدهای نوشته شده را سخت می‌کند.</p>


<p dir="rtl">
مصادیق متعددی برای کدهای کثیف وجود دارد، اما مهم‌ترین مصداق‌های آن می‌توان به تکرار رویه‌های مورد انجام و ایجاد بی‌نظمی در کد اشاره کرد. رعایت اصول کدنویسی تمیز باعث ایجاد کدهای که باعث ساده(readable)، قابل استفاده مجدد(reusable)  و قابل توسعه(refactorable)  می‌شود. در رویکرد‌های توسعه نرم افزار با استفاده از متدولوژی‌های چابک(agile) رعایت کدنویسی تمیز برای اجرای پروژه از اهمیت بالایی برخوردار است، چرا که اکثرا توسعه‌دهندگان 30 الی 40 درصد زمان خود را برای ایجاد یک برنامه کرده و مابقی زمان آن‌ها صرف نگهداری و دیباگ پروژه می‌شود.</p>


<p dir="rtl">
<strong>اصول کدنویسی تمیز </strong></p>


<p dir="rtl">
همانطور که پیش‌تر اشاره شد برای اجرای یک کد تمیز نیاز هست یک سری قواعد و اصولی رعایت شود. البته مشابه مابقی تکنیک‌ها و ابزارهای برنامه نویسی استفاده از کدنویسی تمیز نیز همواره ضروری نیستند و قوانین موجود در کدنویسی تمیز نیز وحی منزل نیستند و گاهی توسط برخی از توسعه‌دهندگان نقض می‌شوند، اما نکته مهم این است که، این قوانین توسط گروه بزرگی از توسعه دهندگان با تجربه و حرفه ای برای clean code ایجاد شده‌اند و قطعا مزایانی بسیاری در رعایت شدن آن‌ها وجود دارد. در ادامه یکسری نکات برای کدنویسی تمیز در جاواسکریپت را مطرح می‌کنیم که بعضا قابلیت استفاده برای سایر زبان‌ها را نیز دارند.</p>


l

<p dir="rtl">
<strong>مقایسه‌های تمیز </strong></p>




*   همواره برای مقایسه از === به جای == استفاده کنید و اصطلاحا به جای مقایسه نرم از مقایسه سخت استفاده کنید.

<p dir="rtl">
<strong>متغیرهای تمیز</strong></p>




*   همواره باید تلاش کنیم عنوانی صحیح، قابل تلفظ و در خور کاربرد متغیر انتخاب کنیم. مثال نام‌گذاری مناسب و نامناسب را در ادامه مشاهده می‌کنیم: 

    ```
const yyyymmdstr = moment().format("YYYY/MM/DD");     // bad
const currentDate = moment().format("YYYY/MM/DD");    // good
```


*   در هنگام اجرای حلقه بر روی مجموعه داده‌ها حتما از اسامی با معنی استفاده کنید چر که ممکن است در بلوک حلقه یکسری کدهای دیگر نیز نوشته شود و نام متغیر استفاده شده در اواخر حلقه بی معنی به نظر برسد، برای مثال:‌

    ```
// bad 
const users = ["Ali", "Reza", "Mohammad"];
users.forEach(u => {
   doStuff();
   doSomeOtherStuff();
   // some thing 
   // ...
   // ...
   // ...
   // ...
   console.log(u);   // what is `u` , here we might forget about loop ?!
});
```


*   در هنگام استفاده از اندیس‌های آرایه‌ها بهتر است آنها را با یک متغیر میانی استفاده کنیم. مثال:

    ```
// bad
const address = "One Infinite Loop, Cupertino 95014";
const cityZipCodeRegex = /^[^,\\]+[,\\\s]+(.+?)\s*(\d{5})?$/;
saveCityZipCode(
  address.match(cityZipCodeRegex)[1],
  address.match(cityZipCodeRegex)[2]
);

// good
const address = "One Infinite Loop, Cupertino 95014";
const cityZipCodeRegex = /^[^,\\]+[,\\\s]+(.+?)\s*(\d{5})?$/;
const [, city, zipCode] = address.match(cityZipCodeRegex) || [];
saveCityZipCode(city, zipCode);
```


*   در نامگذاری متغیر‌ها یا ویژگی‌ها از اسامی بدیهی استفاده نکنید، برای مثال در مورد یک object به نام house داریم :

    ```
// bad
const House = {
  houseOwner: "Ali zandvakili",
  houseArea: 120.8,
  houseAddress: "p240, naft, zafar, Tehran",
  selled: false,
};
// good
const House = {
  owner: "Ali zandvakili",
  area: 120.8,
  address: "p240, naft, zafar, Tehran",
  selled: false,
};
```



<p dir="rtl">
وقتی داخل object مورد نظر برای House هستیم، استفاده از کلمه House هیچ منفعتی برای کدنویس ندارد و در هنگام استفاده از آن فقط تایپ طولانی تری را خواهیم داشت:</p>



```
function getOwner(house) {
  return house.houseOwner;
}
```




*   در هنگام استفاده از متغیرها و متدها، بجای استفاده از شرط ها و بررسی آرگومان‌های  ورودی از مقدار پیش‌فرض ورودی استفاده کنید. برای مثال:

    ```
// bad
function doSomeThing(name) {
  const thingName = name || "Some default value";
  // ...
}

// good
function doSomeThing(name) {
  const thingName = name || "Some default value";
  // ...
}
```


*   بجای استفاده مستقیم از مقادیر ثابت غیرقابل پیش‌بینی در برنامه، از ثابت‌های خود زبان استفاده کنید. مثال:

    ```
// bad
if (user.age > 30) {
    // do sth
}
// good
if (user.age > USER_MAX_AGE) {
   // do sth
}
```



<p dir="rtl">
<strong>توابع تمیز</strong></p>




*   همواره باید پارامترهای ورودی توابع 2 عدد یا حتی کمتر از آن باشند. دلیل این امر علاوه بر ظاهر ساده و قابل درک سریعتر تابع، امکان تست ساده‌تر و راحت‌تر تابع را فراهم می‌کند. 

    <p dir="rtl">
اکثرا اگر تابع ورودی بیشتر از 2 مورد داشته باشد در حال تلاش برای استفاده بیش از حد مجاز از یک تابع هستیم و بهتر است در مورد کارکرد تابع موردنظر تصمیم دیگری بگیریم، اما اگر در مورد تابع شما این مورد صادق نبود ، می‌توانید با ایجاد یک پارامتر object بتوان تعداد ورودی‌های تابع را کمتر کنید. خوشبختانه برخلاف سایر زبان‌ها، جاواسکریپت امکان ایجاد object در لحظه را می‌دهد و لازم نیست کلاس و wrapper دیگری برای ایجاد object استفاده کرد. برای پیشگیری از اشتباهات احتمالی در استفاده از ورودی obejct نیز می‌توان از حالت destructoring برای object استفاده کرد. مثال:</p>



    ```
// bad
function createUser(name, age, favorites, nationality) {
  // ...
}
// good
function createMenu({ name, age, favorites, nationality }) {
  // ...
}
createMenu({
  name: "Ali",
  age: 25,
  favorites: ["Foo", "Bar"],
  nationality: "iranian"
})
```


*   از اسامی صحیح و کامل برای توابع و متدهای خود استفاده کنید. به طور کلی نام تابع می‌بایست به شکل کامل گویای عملکرد آن‌ها باشد و بیانگر کلی کاری که انجام می‌دهند باشد. برای مثال:

    ```
// bad
function calculate(user) {
  // implementation
}
// good
function calculateUserIncome(income) {
  // implementation
}
```


*   هر تابع تنها می‌بایست یک کار منحصر به فرد را انجام دهد و از انجام چندین کار متفاوت در یک تابع امتناع کنید. برای مثال تصور کنید تابعی نوشته‌ایم که عملیات دریافت لیست کاربران و ارسال ایمیل به آن‌ها را برعهده دارد. کدنویسی تمیز، انجام این‌کار را اشتباه می‌داند و بهتر است دو تابع مجزا، برای دریافت و ارسال ایمیل به کاربران داشته باشیم.
*   با توجه به قانون مربوط به حداکثر تعداد پارامترهای تابع، بعضا توابعی خواهیم داشت که ورودی object دارند. ورودی‌های object را اگر بخواهیم اعتبارسنجی کنیم، می‌بایست از مقادیر default و Object.assign استفاده کنیم. مثال:

    ```
// bad
function createMenu(config) {
  config.title = config.title || "Foo";
  config.body = config.body || "Bar";
  config.buttonText = config.buttonText || "Baz";
  config.cancellable =
    config.cancellable !== undefined ? config.cancellable : true;
}


// good
function createMenu(config) {
  config = Object.assign(
    {
      title: "Foo",
      body: "Bar",
      buttonText: "Baz",
      cancellable: true
    },
    config
  );
}
```


*   در مثال فوق اگر از destructuring استفاده می‌کردیم، می‌توانستیم حتی ساده‌تر ورودی‌های تابع را کنترل کرده و در صورت undefined بودن مقدار پیش‌فرض را استفاده کنیم. مثال: 

    ```
function createMenu({
  title = "Foo",
  body = "Bar",
  buttonText = "Baz",
  cancellable = true
}) {
  // ...
}
```


*   توابع pure و بدون side effect ایجاد کنید. افکت‌ها به طور کلی به هر عمل خارج از scope تابع و دنیای بیرون از آن اطلاق می‌شوند که ماژولار بودن برنامه را زیر سوال می‌برند. از جمله افکت‌های مشهور در توابع می‌توان به دستکاری یک object، استفاده از متغیرهای scope بالاتر، چاپ کردن یا نمایش یک مقدار.   برای مثال حالت‌های زیر نقض ایجاد افکت در تابع را نشان می‌دهد :

    ```
// bad
function addToCart(cart, product) => {
  cart.push(product);
}

// good
function addToCart(cart, product) => {
  return [...cart,product];
}

// bad
let name = "Ali ahmadian";
function sayWelcome() {
  return `welcome ${name}`;
}

// good
function sayWelcome(name) {
  return `welcome ${name}`;
}
```



<p dir="rtl">
نکته حائز اهمیت در مورد clone کردن object در تکه کد فوق این است که اگر object بزرگی داشته باشیم clone کردن آن با استفاده از عملگر spread، بهینه نمی‌باشد و بهتر است از پکیج‌های خوبی که برای انجام تغییر در object به شکل immutable را میسر می‌سازد استفاده کنیم. نمونه مشهور این‌گونه کتابخانه‌ها می‌توان به immutablejs و immer اشاره کرد.</p>




*   تا حد امکان به جای برنامه‌نویسی دستوری از برنامه‌نویسی تابعی استفاده کنید. مثال واضح این مورد استفاده از توابع آرایه‌ها و ایجاد higher order functions است برای کاربردهای مختلف است.
*   از انتخاب اسامی منفی برای تابع پرهیز کنید. اسامی که دارای not باشند یا منفی بودن را اعلام کنند، مثل :

    ```
// bad
if (!isUserNotLoggedIn(user)) {
  // ...
}
// good
if (isUserLoggedIn(node)) {
  // ...
}
```



<p dir="rtl">
<strong>سایر موارد کدنویسی تمیز</strong></p>




*   از کامنت‌گذاری‌های بیهوده و زیاد خودداری کنید، چرا که کدهایی که به نحوه احسن نوشته شده باشند نیاز به کامنت‌گذاری زیادی ندارند و خود کد بیانگر کاریست که انجام می‌دهد.
*   از اصول SOLID غافل نشوید و همواره سعی کنید DRY و KISS کدنویسی کنید.

<p dir="rtl">
در این بخش به یکسری نکات کلی برای کدنویسی تمیز اشاره کردیم، اما برای نوشتن کدهای با کیفیت بالا، بهتر است ساختمان داده‌ها را درک کرده و از اصول طراحی الگوریتم‌‌های بهینه و همچنین دیزاین پترن‌‌ها در کدنویسی خود استفاده کنید.</p>


<p dir="rtl">
<strong>تست نویسی</strong></p>


<p dir="rtl">
اگر کدی نوشته‌اید که در با وضعیت فعلی کدها اجرا می‌شود، به معنای قابل اعتماد بودن آن نیست، چرا که کدهای برنامه شما هر روز بهبود پیدا می‌کنند یا بخش‌های جدیدی به آن‌ها اضافه می‌شوند و برای اطمینان از اجرای صحیح برنامه، می‌بایست تمام بخش‌های برنامه را باز کرده و از اجرای صحیح آن‌ها مطمئن شویم. این شیوه از تست کردن، تست دستی نامیده می‌شود که نیاز به زمان و دقت بالایی دارد. نوع دیگری از تست وجود دارد که به صورت اتوماتیک اجرا می‌شود و بخش(unit)هایی از برنامه را به شکل جداگانه تست کرده و از اجرای صحیح هر بخش مطمئن می‌شویم.</p>


<p dir="rtl">
ممکن است برایتان پیش بیاید که برنامه‌نویسان‌هایی را مشاهده کنید که در کل عمر برنامه‌نویسی‌شان از تست‌نویسی استفاده نکرده‌اند و یا حتی با ماهیت نوشتن تست‌نویسی موافق نیستند. اما اگر به تست‌نویسی عادت کنید، به هیچ‌وجه حاضر نخواهید بود بدون نوشتن تست، کدی بنویسید. بعلاوه در کدنویسی پروژه‌های متن‌باز و یا با تیم‌های بزرگ، اکثر برنامه‌نویسان حرفه‌ای نوشتن تست را ضروری می‌دانند و حتی بعضا در پروژه‌های بدون تست همکاری نمی‌کنند.</p>


<p dir="rtl">
در برنامه‌هایی که پیچیدگی نسبتا بالایی دارند، تغییر دادن یک بخش از برنامه، توسعه بخش‌های دیگر و یا نیاز به refactor کردن سیستم، دلایلی هستند که وجود تست برای برنامه را ضروری می‌کنند.</p>


<p dir="rtl">
<strong>معرفی و مقایسه کتابخانه های تست</strong></p>


<p dir="rtl">
</p>


<p dir="rtl">
<strong>پس از مطالعه این فصل انتظار می رود </strong></p>




*   مورد اول
*   مورد دوم
*   مورد سوم
*   مورد چهارم

<p dir="rtl">
 \
</p>

